[TOC]

# 维护信息

|序号|版本|发布人|修改原因即说明|日期|
|-|-|-|-|-|
|1|v0.0|沈正昊|架构调整，核心代码封装C语言，python接口|2020年11月25日|

# 模型概述

## 模型目的

主要功能如下：

1. 根据现有人口结构热、历史人口变动信息以及相关统计信息预测未来年度人口数目及结构；
2. 根据人口预测，预测医保筹资、费用数额、变化等信息；
3. 基于用户需求，提供退休年龄调整以及目标预测人口功能；

## 模型架构

模型采用C语言封装动态链接库为核心代码，python提供数据及调用接口的架构。采用该架构的主要因素有：

1. 性能：该架构的性能足以满足各种场景，无需增添硬件或其他设备。
2. 保密：C语言封装的动态链接库去除了symbol后只有入口函数可查，逆向难度极大。
3. 兼容：manylinux平台编译使得链接库可在绝大多数linux发行版运行，python接口解决了调用和启动的问题

### 核心代码结构

核心代码分为3层接口，即：
1. [主函数](#主函数)：主要的运行逻辑，各个模块之间的调用
2. [模块结构](#模块结构)：一类功能会由一个模块结构描述，该模块结构包含了具体的数据及函数
3. [模块属性和方法](#模块属性及方法)：具体的实行代码和存放计算数据的结构

下面依次以现有的版本进行介绍

#### 主函数

以下是预测模型主函数，主要功能是依次调用每个模块的<code>Init</code>，<code>Run</code>以及<code>rls</code>函数

```c
DLL_EXP int modl_run(void)
{
    int i, ret;
    for(i = 0; i < NO_OBJ; i++){
        if((unsigned long)list_objs[i]->Init){
            ret = list_objs[i]->Init(list_objs[i]);
            if(ret < 0){
                printf("%s",&(list_objs[i]->init_err[0]));
                return EXIT_FAILURE;
            }
        }
    }
    for(i = 0; i < NO_OBJ; i++){
        if((unsigned long)list_objs[i]->Run){
            ret = list_objs[i]->Run(list_objs[i]);
            if(ret < 0){
                printf("%s",&(list_objs[i]->run_err[0]));
                return EXIT_FAILURE;
            }
        }
    }
    for(i = 0; i < NO_OBJ; i++){
        if((unsigned long)list_objs[i]->Run){
            list_objs[i]->rls(list_objs[i]);
        }
    }
    memset(&list_param,0,sizeof(struct_list_param));
    printf("hello world\n");
    return EXIT_SUCCESS;
}
```

#### 模块结构

模型主要划分为以下5个模块：

1. [<code>targ_pop</code>](#targ_pop)：用于目标预测人口功能下的人口预测
2. [<code>next_pop</code>](#next_pop)：用于一般目的下的人口预测
3. [<code>ret_adj</code>](#ret_adj)：基于退休年龄对已与预测的人口进行调整
4. [<code>prem</code>](#prem)：基于人口计算筹资的模块
5. [<code>expen</code>](#expen)：基于人口计算费用的模块

每个模块具有以下定义的头部结构：

```c
typedef struct{
    int (*Run)(void *this);
    int (*Init)(void *this);
    void (*rls)(void *this);
    char init_err[ERR_LEN];
    char run_err[ERR_LEN];
}struct_obj_head;
```

其中：

1. <code>Init</code>：模块的初始化函数指针，指向的函数用于初始化数据，分配空间，整理相关数据格式等
2. <code>Run</code>：运行函数指针，用于计算模型相关结果
3. <code>rls</code>：运行后处理，用于释放内存，归零相应数据以防止进程不终结

#### 模块属性及方法

每个模块拥有自己的数据和函数指针，可指向不同或相同的数据及函数。通过模块间的组合，模型完成一系列的计算要求。

该部分是模型的具体运算单元，实现了各种算法下的计算。

# 详细说明

该部分说明模型的具体计算方法。由于核心代码是按模块编写的，故此处也按照模块进行划分。

由于所有计算均在一定维度上汇总，为方便表述故定义：
1. $s$ 为性别，其中 $s=0$ 是男性； $s=1$ 是女性
2. $a$ 为年龄，取值范围 $0\leq a\leq 105$
3. $c$ 为人员类别，其中 $c=1$ 是普通居民； $c=2$ 是少年儿童及学生； $c=W$ 是在岗职工； $c=R$ 是退休人员
4. $y$ 为预测年度，且 $y=st$ 是预测开始年度； $y=ed$ 是预测结束年度
5. $t$ 为就诊类型，其中 $t=0$ 是门诊； $t=1$ 是住院

## targ_pop

用于计算在目标预测人口功能开启时计算预测人口，若功能结束年度小于预测年度，则结束年度后将使用[next_pop](#next_pop)模块计算。

### targ_pop入参

入参包含基础年度的人口数，从外部获取：

```c
typedef struct{
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double pop;                 //人口数量
}struct_para_pol;
```

以及用户输入的目标人口，从外部获取：

```c
typedef struct {
    int fort_year;  //目标年度
    double tot_pop; //目标人口
} struct_input_fort_pop;
```

### targ_pop计算

计算主要分为两部分，准备[基础年度的人口比例](#基础年度人口比例)，以及计算[预测年度人口](#预测年度人口)，具体计算方法如下：

#### 基础年度人口比例

定义人口比例 

$$P_{(s,a,c)}=\frac{E_{(s,a,c,st)}}{\sum E_{(s,a,c,st)}}$$ 

其中:

1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
2. $E_{(s,a,c,y)}$ 代表该性别，年龄，人员类别，下的[人口数量](#targ_pop入参)
3. $st$ 为基础年度

##### 预测年度人口

目标中人口为[用户输入](#targ_pop入参)，分别为对于预测年度 $y^*$ 的总人口数 $S^*_{y^*}$ 

定义 $y^*$ 组成的集合为 $Y^*$ ，

定义函数 $U(y)=\{y’|y'>y\land y'\in Y^*\},D(y)=\{y’|y'<y\land y'\in Y^*\}$

继而定义 $\min(y)$ 为 $U(y)$ 最小值， $\max(y)$ 为 $D(y)$ 最大值

则有：

$S(y)=\begin{cases}
   S^*_{y}&y\in Y^*\\
   S^*_{\max(y)}+\big(y-\max(y)\big)\times\frac{S^*_{\min(y)}-S^*_{\max(y)}}{\min(y)-\max(y)}& y\not\in Y^*
\end{cases}$

则 $y$ 预测年度 $s$ 性别 $a$ 年龄 $p$ 人员类别的人口预测数为 $E'_{(s,a,c,y)}=S_{y}*P_{(s,a,c)}$

## next_pop

用于计算一般情况下，基于前一年度人口分布计算下一年度人口变化及分布

### next_pop入参

入参包含基础年度的人口数，外部参数获取：

```c
typedef struct{
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double pop;                 //人口数量
}struct_para_pol;
```

死亡率数据，外部参数获取：

```c
typedef struct{
    int gend;       //性别
    int age;        //年龄
    double dierat;  //死亡率
} struct_para_dierate;
```

转化率数据，外部参数获取。其中转化率是根据历史经验计算的<span style="color:red">上一年度特定年龄，性别下人口总数与本年度同样性别，年龄加一以及特定人员类别下的人口数比值的期望</span>，由参数计算模块计算：

```c
typedef struct {
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double finl_rate;           //转化率
    ...
}struct_para_rat;
```

新生儿相关数据，外部获取

```c
typedef struct{
    ...
    double birth_rate;  //生育率
    double male_ratio;  //新生儿男性比例
    int birthAgeST;     //最小生育年龄
    int birthAgeED;     //最大生育年龄
    ... 
} struct_run_param;
```

死亡率调整参数，从外部获得

```c
typedef struct{
    ...
    double Mort_Adj[2][106];    //死亡率调整参数
    ... 
} struct_run_param;
```

### next_pop计算

#### 已有人口

根据转换率参数计算下一年度，下一岁的人口数量：

$$E_{(s,a+1,c,y+1)}=\left(\sum_{c\in\{R,W,1,2\}}E_{(s,a,c,y)}\right)\times R_{(s,a,c)}\times(1-q_{(s,a)}\times q^{adj}_{(s,a)})$$

上述公式中：
1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
2. $E_{(s,a,c,y)}$ 代表该“性别$=s$，年龄$=a$，人员类别$=c$，预测年度$=y$”下的[人口数](#next_pop入参)
3. $R_{(s,a,c)}$ 为“性别$=s$，年龄$=a$”下所有人口下一年转化到“性别$=s$，年龄$=a+1$，人员类别 $=c$”的[转化率](#next_pop入参)参数
4. $q_{(s,a)}$ 为“性别$=s$，年龄$=a$”下的[死亡率](#next_pop入参)
5. $q_{adj}$ 为“性别$=s$，年龄$=a$”下的[死亡率调整参数](#next_pop入参)

#### 新生儿

该部分公式延续上一步定义。

完成已有人口计算后，根据计算结果进一步计算新生儿数量：

<a id="nb_calc"></a>
$$E_{(s,0,2,y)}=\begin{cases}
    r\times R_{birth}\left(\sum_{s=1\land m\leq a\leq M}E_{(s,a,c,y)}\right)&s=0\\
    (1-r)\times R_{birth}\left(\sum_{s=1\land m\leq a\leq M}E_{(s,a,c,y)}\right)&s=1
\end{cases}
$$

上述公式延续第一步定义的符号，另根据[配置参数](#newborn)有：
1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
   其中 $s=0$ 代表男性； $s=1$ 代表女性。 
   $c=2$ 表示人员类别为“少年儿童或大学生”
2. $r$ 为"male_ratio"即[新生儿男性比例](#next_pop入参)
3. $m,M$ 分别代表“BirthAgeST”和“BirthAgeED”，即[最小/大生育年龄](#next_pop入参)
4. $R_{birth}$ 代表“birth_rate”，即[生育率](#next_pop入参)

## ret_adj

用于在开启退休年龄调整时重新调整人口分布。

### ret_adj入参

已经由[targ_pop](#targ_pop)或[next_pop](#next_pop)计算所得的人口数

```c
typedef struct{
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double pop;                 //人口数量
}struct_para_pol;
```

用户输入的新退休年龄，外部获取

```c
typedef struct {
    int fort_year;  //预测年度
    int gend;       //性别
    int retr_age;   //新退休年龄
} struct_input_retr_adjm;
```

当前退休年龄，根据国家法定退休年龄为男65，女55

### ret_adj计算

#### 计算相关Ratio

在某个确定的预测年度 $y$ ，根据[基础逻辑](#基础计算)得到的结果，计算以下4个比例：

$\begin{aligned}
&r_1=\frac{\sum_{a<R_{New}\land c=W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c=R}E_{(s,a,c,y)}}{\sum_{a<R_{New}\land c=W}E_{(s,a,c,y)}\left(1+\frac{\sum_{a<R_{Cur}\land c=R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c=W}E_{(s,a,c,y)}}\right)}\\
&r_2=\frac{\sum_{a<R_{New}\land c=W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c=R}E_{(s,a,c,y)}}{\sum_{a<R_{New}\land c=R}E_{(s,a,c,y)}\left(1+\frac{\sum_{a<R_{Cur}\land c=W}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c=R}E_{(s,a,c,y)}}\right)}\\
&r_3=\frac{\sum_{a\geq R_{New}\land c=W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c=R}E_{(s,a,c,y)}}{\sum_{a\geq R_{New}\land c=W}E_{(s,a,c,y)}\left(1+\frac{\sum_{a\geq R_{Cur}\land c=R}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c=W}E_{(s,a,c,y)}}\right)}\\
&r_4=\frac{\sum_{a\geq R_{New}\land c=W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c=R}E_{(s,a,c,y)}}{\sum_{a\geq R_{New}\land c=R}E_{(s,a,c,y)}\left(1+\frac{\sum_{a\geq R_{Cur}\land c=W}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c=R}E_{(s,a,c,y)}}\right)}\\
\end{aligned}$

上述公式中：
1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
   其中 $c=W$ 代表在岗职工；$c=R$ 代表退休
2. $E_{(s,a,c,y)}$ 代表性别$=s$，年龄$=a$，人员类别$=c$，预测年度$=y$下的人口数量
3. $R_{New}$ 为用户输入的[新退休年龄](#ret_adj入参)；$R_{Cur}$ 为[当前退休年龄](#ret_adj入参)
4. $\sum$ 记号的加和维度为满足下标条件，预测年度 $y$ 的所有年龄，性别，人员类别的加和。

#### 调整人口分布

根据上一步计算出的Ratio，以及[基础逻辑](#基础计算)计算得的人口，对人口分布做如下调整：

$\begin{aligned}
   &E'_{(s,a,c,y)}=\begin{cases}
      E_{(s,a,c,y)}& c\ne W\land c\ne R\\
      E_{(s,a,c,y)}\times r_1 &c=W\land a < R_{New}\\
      E_{(s,a,c,y)}\times r_2 &c=R\land a < R_{New}\\
      E_{(s,a,c,y)}\times r_3 &c=W\land a\geq R_{New}\\
      E_{(s,a,c,y)}\times r_4 &c=R\land a\geq R_{New}\\
   \end{cases}
\end{aligned}$

上述公式中 $E'_{(s,a,c,y)}$ 为退休年龄调整后的人口。

### ret_adj算法基础

采用上述计算方法调整退休年龄的主要逻辑包含：

1. 调整后新退休年龄之前/后的退休在职比例不变，证明如下：
   
   $\begin{aligned}
   &\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}\times R_1\div \sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}\times R_2\\
   =&\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}}}\div\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}}\\
   =&\frac{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}}{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}+\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}}}\\
   =&\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}\div\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}\\\\
   &\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}\times R_3\div \sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}\times R_4\\
   =&\frac{\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}}}\div\frac{\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}}}\\
   =&\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}\div \sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}
   \end{aligned}$

2. 调整前后，新的退休年龄之前，之后的人口总数不变。证明如下：

   $\begin{aligned}
   &\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}\times R_1+ \sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}\times R_2\\
   =&\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}}}+\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}}\\
   =&\left(\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}\right)\frac{\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}}{\sum_{a<R_{Cur}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{Cur}\land c\in R}E_{(s,a,c,y)}}\\
   =&\sum_{a<R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a<R_{New}\land c\in R}E_{(s,a,c,y)}\\\\
   &\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}\times R_3+ \sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}\times R_4\\
   =&\frac{\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}}}+\frac{\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}}{1+\frac{\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}}}\\
   =&\left(\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}+\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}\right)\frac{\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}}{\sum_{a\geq R_{Cur}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{Cur}\land c\in R}E_{(s,a,c,y)}}\\
   =&\sum_{a\geq R_{New}\land c\in W}E_{(s,a,c,y)}+\sum_{a\geq R_{New}\land c\in R}E_{(s,a,c,y)}
   \end{aligned}$

## prem

基于前三个模块计算完成的人口数，计算预测个帐和基金<span style="color:red">筹资</span>数

### prem入参

基于前三个模块计算完成的人口数

```c
typedef struct{
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double pop;                 //人口数量
}struct_para_pol;
```

830模型代码需要用户输入的830参数，外部获得

```c
typedef struct{
    int fort_year;                  //预测年度
    char psn_type[CHAR_LEN];        //人员类别
    double psn_clctstd;             //人均个人缴费基数
    double emp_clctstd;             //人均公司缴费基数
    double psn_clctprop;            //个人缴费比例
    double emp_clct_rate;           //公司缴费比例
    double psn_acct_fund_clctprop;  //个人缴费进个人账户比例
    double emp_acct_fund_clctprop;  //公司缴费进个人账户比例
    double acct_fund_clctstd;       //人均统筹转个人账户缴费基数
    double acct_fund_clctprop;      //统筹转个人账户缴费比例
    double soca_avesal;             //社会平均工资
    double soca_avesal_growrat;     //社会平均工资增长率
    double rsdt_clctprop;           //居民缴费比例
}struct_prem_input_830;
```

715模型代码需要715的用户输入参数：

```c
typedef struct{
    int fort_year;                  //预测年度
    char psn_type[CHAR_LEN];        //人员类别
    double soca_avesal;             //社会平均工资
    double soca_avesal_growrat;     //社会平均工资增长率
    double perpsn_dsop_inc;         //人均可支配收入
    double perpsn_dsop_inc_growrat; //人均可支配收入增长率
}struct_prem_input_715;
```

根据历史数据计算的筹资参数：

```c
typedef struct {
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double finl_rate;           //转化率
    double acct_prop;           //个帐比例
    double fund_prop;           //统筹比例
}struct_para_rat;
```

### prem计算

#### 715

715模型由于前端输入为基数，故仅需乘以相应比例即可：

$\begin{aligned}
ACCT_{(s,a,c,y)}&=\begin{cases}
   E_{(s,a,c,y)}\times Ave_S\times(1+R_S)^{y-st}\times ACCT\_TOT_{(s,a,c)}&c\in\{W,R\}\\
   E_{(s,a,c,y)}\times Ave_I\times(1+R_I)^{y-st}\times ACCT\_TOT_{(s,a,c)}&c\in\{1,2\}\\
\end{cases}\\
FUNT_{(s,a,c,y)}&=\begin{cases}
   E_{(s,a,c,y)}\times Ave_S\times(1+R_S)^{y-st}\times FUND\_TOT_{(s,a,c)}&c\in\{W,R\}\\
   E_{(s,a,c,y)}\times Ave_I\times(1+R_I)^{y-st}\times FUND\_TOT_{(s,a,c)}&c\in\{1,2\}\\
\end{cases}
\end{aligned}$

上述公式中：
1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
   其中 $c=1$ 代表人员类别是普通居民， $st$ 代表预测开始年度
2. $E_{(s,a,c,y)}$ 代表该性别$=s$，年龄$=a$，人员类别$=c$，预测年度$=y$下[预测人口数量](#prem入参)
3. $ACCT_{(s,a,c,y)},FUNT_{(s,a,c,y)}$ 分别代表性别$=s$，年龄$=a$，人员类别$=c$，预测年度$=y$下的个账缴费和基金缴费
4. $Ave_S,Ave_I$ 分别代表[用户输入](#prem入参)的社平工资和人均可支配收入
5. $R_S,R_I$ 分别代表[用户输入](#prem入参)的社平工资增长率和人均可支配收入增长率
6. $ACCT\_TOT_{(s,a,c)},FUND\_TOT_{(s,a,c)}$分别代表性别$=s$，年龄$=a$，人员类别$=c$下的个帐比例和统筹比例[参数](#prem入参)

#### 830

由于入参及符号较多，故做以下定义：

1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
2. $E_{(s,a,c,y)}$ 代表该性别，年龄，人员类别，预测年度下预测人口数量
3. $I[0]_{(c,y)}\sim I[10]_{(c,y)}$ 分别代表[用户输入](#prem入参)中人员类别$=c$，预测年度$=y$的：
   |定义|
   |-|
   |人均个人缴费基数|
   |人均公司缴费基数|
   |个人缴费比例|
   |公司缴费比例|
   |个人缴费进个人账户比例|
   |公司缴费进个人账户比例|
   |人均统筹转个人账户缴费基数|
   |统筹转个人账户缴费比例|
   |社会平均工资|
   |社会平均工资增长率|
   |居民缴费比例|

4. 同理 $P[0]_{(s,a,c)}\sim P[1]_{(s,a,c)}$ 分别代表以下[入参](#prem入参)：
   |定义|
   |-|
   |个帐比例|
   |统筹比例|
定义特定性别，年龄，人员类别，预测年度下人均个人缴费（ $Id_{(s,a,c,y)}$ ）、公司缴费（ $Cp_{(s,a,c,y)}$ ）、统筹转个帐金额（ $Tr_{(s,a,c,y)}$ ）和居民缴费（ $Cz_{(s,a,c,y)}$ ）分别为：

$\begin{aligned}
Id_{(s,a,c,y)}&=I[0]_{(c,y)}\times I[2]_{(c,y)}\times\prod_{i=st}^y(1+I[9]_{(c,i)})\\
Cp_{(s,a,c,y)}&=I[1]_{(c,y)}\times I[3]_{(c,y)}\times\prod_{i=st}^y(1+I[9]_{(c,i)})\\
Tr_{(s,a,c,y)}&=I[6]_{(c,y)}\times I[7]_{(c,y)}\times\prod_{i=st}^y(1+I[9]_{(c,i)})\\
Cz_{(s,a,c,y)}&=I[10]_{(c,i)}\times I[8]_{(c,y)}\times\prod_{i=st}^y(1+I[9]_{(c,i)})
\end{aligned}$

进一步有特定性别，年龄，人员类别，预测年度下个账缴费 $ACCT_{(s,a,c,y)}$ 以及基金缴费 $FUNT_{(s,a,c,y)}$ 如下：

$\begin{aligned}
ACCT_{(s,a,c,y)}&=\begin{cases}
   0&c\in\{1,2\}\\
   P[0]_{(s,a,c)}\times E_{(s,a,c,y)}\times \left(Id_{(s,a,c,y)}\times I[4]_{(c,y)}+Cp_{(s,a,c)}\times I[5]_{(c,y)}\right)&c= W\\
   P[0]_{(s,a,c)}\times E_{(s,a,c,y)}\times Tr_{(s,a,c,y)}& c= R
\end{cases}\\
FUNT_{(s,a,c,y)}&=\begin{cases}
   P[1]_{(s,a,c)}\times E_{(s,a,c,y)}\times Cz_{(s,a,c,y)} & c\in \{1,2\}\\
   P[1]_{(s,a,c)}\times E_{(s,a,c,y)}\times \left(Id_{(s,a,c,y)}\times (1-I[4]_{(c,y)})+Cp_{(s,a,c)}\times (1-I[5]_{(c,y)})\right)& c= W\\
   P[1]_{(s,a,c)}\times E_{(s,a,c,y)}\times \left(Id_{(s,a,c,y)}+Cp_{(s,a,c,y)}-Tr_{(s,a,c,y)}\right)& c= R\\
\end{cases}
\end{aligned}$


## expen

基于前三个模块计算完成的人口数，计算预测个帐和基金<span style="color:red">支出</span>数

### expen入参

基于前三个模块计算完成的人口数

```c
typedef struct{
    int gend;                   //性别
    int age;                    //年龄
    char psn_type[CHAR_LEN];    //人员类别
    double pop;                 //人口数量
}struct_para_pol;
```

830模型代码需要用户输入的830参数，外部获得

```c
typedef struct{
    int fort_year;              //预测年度
    char psn_type[CHAR_LEN];    //人员类别
    int mdtrt_type;             //就诊类别
    double mdtrt_rate_grow;     //就诊次数增长率
    double avg_fee_grow;        //次均费用增长率
    double covr_prop_grow;      //报销比例增长率
    double reim_rat_grow;       //统筹支出比例增长率
}struct_prem_input_830;
```

715模型代码需要715的用户输入参数，以及计算医疗通胀的输入参数：

```c
typedef struct{
    int fort_year;      //预测年度
    double gdp;         //GDP
    double gdp_growrat; //GPD增长率
}struct_exp_input_715;
typedef struct{
    ...
    double ExFact;  //人均卫生费用增长率
    double Medi_R;  //均度医疗费用占人均GDP比例
} struct_run_param;
```

### expen计算

#### 715

##### 人均卫生费用增长率

基础年度的GDP增长率、人均度医疗费用占人均GDP比例、人口数量以及人均卫生费用增长率可从[用户输入](#expen入参)和[参数管理](#expen入参)中提取。

定义预测年度为 $y$ ，则根据[用户输入](#expen入参)的上年度GDP增长率 $G^u_{y-1}$ 以及本年度、上一年度的在保人口数 $E_y,E_{y-1}$ 预估本年度人均GDP $\overline{G}_y$

$$\overline{G}_y=\frac{\frac{GDP_y}{E_y}}{\frac{GDP_{y-1}}{E_{y-1}}}-1=\frac{\frac{GDP_y}{GDP_{y-1}}}{\frac{E_y}{E_{y-1}}}-1=\frac{1+G^u_{y-1}}{E_y/E_{y-1}}-1$$

根据上一年人均卫生费用增长率 $\overline{M}_{t-1}$ 上年度、本年人均度医疗费用占人均GDP比例 $S_y,S_{y-1}$ 以及上年度人均GDP增长率 $\overline{G}_{y-1}$ 计算本年度人均度医疗费用占人均GDP比例

$$S_y=S_{y-1}\frac{1+\overline{M}_{y-1}}{1+\overline{G_{y-1}}}$$

根据修正比例阀值 $R$ 以及医疗超出部分 $X_y$ 计算本年度医疗超出部分

$$X_y=X_{st}*\left(1-\left(\frac{\max(0,S_y-R)}{R}\right)^{0.5}\right)$$

此处根据参考文章中的公式计算，其中惩罚参数的次数（0.5，用于放大）依照文中定义。且文中指出该系数一般不应被修改。修正比例阀值同样参考文中为 $R=S_{st}\times 1.25$ 即初始年度人均度医疗费用占人均GDP比例的 $1.25$ 倍

最后计算本年度人均卫生费用增长率

$$\overline{M}_y=(1+\overline{G}_y)(1+X_y)-1$$

$$\forall y\rightarrow \frac{E_y}{E'_y}=c\in\mathbb{R}$$

$$E_y=cE'_y$$

$$\frac{E_{y+1}}{E_y}=\frac{cE'_{y+1}}{cE'_y}=\frac{E'_{y+1}}{E'_y}$$

##### 费用计算

作以下定义：

1. $s,a,c,y,t$ 分别代表性别，年龄，人员类别，预测年度以及就诊类别
2. $E_{(s,a,c,y)}$ 代表该性别，年龄，人员类别，预测年度下预测人口数量
3. $C[0]_{(s,a,c)}\sim C[3]_{(s,a,c)}$ 分别代表[参数表](#expen入参)中：
   |定义|
   |-|
   |人均就诊次数|
   |次均费用|
   |次均医保支付|
   |次均统筹支付|
4. $\overline{M}_y$ 代表预测年度$=y$下的[人均卫生费用增长率](#人均卫生费用增长率)

则有特定性别，年龄，人员类别，预测年度下就诊次数（ $Ocur_{(s,a,c,y)}$ ），总费用（ $Tchr_{(s,a,c,y)}$ ），可报销费用（ $Cchr_{(s,a,c,y)}$ ），实际报销费用（ $Pchr_{(s,a,c,y)}$ ）入下：

$\begin{aligned}
   Ocur_{(s,a,c,y,t)}&=E_{(s,a,c,y)}\times C[0]_{(s,a,c,t)}\\
   Tchr_{(s,a,c,y,t)}&=Ocur_{(s,a,c,y,t)}\times C[1]_{(s,a,c,t)}\times\prod_{i=st}^y(1+\overline{M}_i)\\
   Cchr_{(s,a,c,y,t)}&=Tchr_{(s,a,c,y,t)}\times C[2]_{(s,a,c,t)}\\
   Pchr_{(s,a,c,y,t)}&=Cchr_{(s,a,c,y,t)}\times C[3]_{(s,a,c,t)}
\end{aligned}$

#### 830

作以下定义：

1. $s,a,c,y$ 分别代表性别，年龄，人员类别以及预测年度
2. $E_{(s,a,c,y)}$ 代表该性别，年龄，人员类别，预测年度下预测人口数量
3. $M[0]_{(y,c,t)}\sim M[3]_{(y,c,t)}$ 代表830用户输入中的：
   |定义|
   |-|
   |就诊次数增长率|
   |次均费用增长率|
   |医保支付增长率|
   |统筹支付增长率|
4. $C[0]_{(s,a,c)}\sim C[3]_{(s,a,c)}$ 分别代表参数表中：
   |定义|
   |-|
   |人均就诊次数|
   |次均费用|
   |次均医保支付|
   |次均统筹支付|

则有特定性别，年龄，人员类别，预测年度下就诊次数（ $Ocur_{(s,a,c,y)}$ ），总费用（ $Tchr_{(s,a,c,y)}$ ），可报销费用（ $Cchr_{(s,a,c,y)}$ ），实际报销费用（ $Pchr_{(s,a,c,y)}$ ）如下：

$\begin{aligned}
   Ocur_{(s,a,c,y,t)}&=E_{(s,a,c,y)}\times\left(C[0]_{(s,a,c)}\times\prod_{y'=y_0}^y(1+M_{y,c,t})\right)\\
   Tchr_{(s,a,c,y,t)}&=Ocur_{(s,a,c,y,t)}\times \left(C[1]_{(s,a,c)}\times\prod_{y'=y_0}^y(1+M_{y,c,t})\right)\\
   Cchr_{(s,a,c,y,t)}&=Tchr_{(s,a,c,y,t)}\times \left(C[2]_{(s,a,c)}\times\prod_{y'=y_0}^y(1+M_{y,c,t})\right)\\
   Pchr_{(s,a,c,y,t)}&=Cchr_{(s,a,c,y,t)}\times \left(C[3]_{(s,a,c)}\times\prod_{y'=y_0}^y(1+M_{y,c,t})\right)
\end{aligned}$